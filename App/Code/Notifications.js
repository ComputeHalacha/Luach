import { DeviceEventEmitter, BackHandler } from 'react-native';
import PushNotification from 'react-native-push-notification';
import PushNotificationAndroid from 'react-native-push-notification';
import { log, getRandomNumber } from './GeneralUtils';
import Settings from './Settings';
import Utils from './Utils';
import Zmanim from './Zmanim';
import { getZmanType } from './ZmanTypes';

export function configureNotifier() {
    PushNotification.configure({
        // (optional) Called when Token is generated (iOS and Android)
        onRegister: function(token) {
            log('TOKEN:', token);
        },

        // (required) Called when a remote or local notification is opened or received
        onNotification: async function(notification) {
            log('NOTIFICATION:', notification);
        },
        popInitialNotification: true,
        requestPermissions: true,
    });
}

/**
 * Adds a system local scheduled notification
 * @param {Number} id
 * @param {String} title
 * @param {String} message
 * @param {Date} date
 */
export function addNotification(id, title, message, date) {
    PushNotification.localNotificationSchedule({
        date,
        message,
        id: id.toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
        ticker: 'Luach Alarm',
        autoCancel: true,
        //largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
        //smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
        bigText: message,
        subText: title,
        //color: "red", // (optional) default: system default
        vibrate: true,
        vibration: 1000,
        //tag: 'some_tag', // (optional) add tag to message
        //group: "group", // (optional) add group to message
        ongoing: false,
        priority: 'high',
        visibility: 'private',
        importance: 'high',
        title: title,
        playSound: true,
        soundName: 'default',
        number: '10',
        //repeatType: 'day', // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
        //actions: '["Confirm", "Snooze"]',
    });
}

/**
 * Schedules the upcoming notification for the given Zman type
 * @param {{id:Number, title:String, text:String, zmanName:String, alarmOffset:int, days:[]}} activeAlarm
 * @param {Location} location
 */
export function addNextNotification(activeAlarm, location) {
    const now = new Date(),
        zmanType = getZmanType(activeAlarm.zmanName);
    //Start with now. Note, if the current time is after the zman time, tomorrows zman will be returned.
    let nextZmanDate = Zmanim.getNextZmanTime(zmanType.name, now, location),
        nextAlarmDate = new Date(
            nextZmanDate.getTime() + activeAlarm.alarmOffset * 60000
        );
    if (
        activeAlarm.days.length &&
        !activeAlarm.days.includes(nextZmanDate.getDay())
    ) {
        while (
            !activeAlarm.days.includes(nextZmanDate.getDay()) ||
            now.getTime() >= nextAlarmDate.getTime()
        ) {
            nextZmanDate = Zmanim.getNextZmanTime(
                activeAlarm.zmanName,
                Utils.addDaysToSdate(1),
                location
            );
            nextAlarmDate = new Date(
                nextZmanDate.getTime() + activeAlarm.alarmOffset * 60000
            );
        }
    }
    const zmanTimeObj = Utils.timeFromDate(nextZmanDate),
        zmanTimeText = Utils.getTimeString(zmanTimeObj),
        fullText =
            activeAlarm.text + '\n' + zmanType.eng + ' is at ' + zmanTimeText;

    addNotification(activeAlarm.id, activeAlarm.title, fullText, nextAlarmDate);
}

/**
 *
 * @param {{id:Number, title:String, text:String, zmanName:String, alarmOffset:int, days:[]}} activeAlarm
 */
export function cancelAlarm(activeAlarm) {
    PushNotification.cancelLocalNotifications({
        id: activeAlarm.id.toString(),
    });
}

/**
 *
 * @param {{id:Number, title:String, text:String, zmanName:String, alarmOffset:int, days:[]}} activeAlarm
 * @param {Location} location
 */
export function regenerateAlarm(activeAlarm, location) {
    cancelAlarm(activeAlarm);
    addNextNotification(activeAlarm, location);
}

/**
 * Clears all scheduled notifications and generates the next instance for all active alarms.
 * @param {Settings} settings
 */
export function regenerateAll(settings) {
    PushNotification.cancelAllLocalNotifications();
    for (let a of settings.activeAlarms) {
        addNextNotification(a, settings.location);
    }
}

(function() {
    // Register all the valid actions for notifications here and add the action handler for each action
    PushNotificationAndroid.registerNotificationActions(['Confirm', 'Snooze']);
    DeviceEventEmitter.addListener('notificationActionReceived', function(
        action
    ) {
        log('Notification action received: ' + action);
        const info = JSON.parse(action.dataJSON);
        if (info.action == 'Snooze') {
            // Add another notification in 10 minutes
            const dt = new Date();
            dt.setMinutes(dt.getMinutes + 10);
            //We will not use the original id as will be already in use
            //for the next iteration of the alarm
            addNotification(getRandomNumber(7), info.title, info.message, dt);
        } else if (info.action === 'Confirm') {
            PushNotification.cancelLocalNotifications({ id: info.id });
        }
        // hide the app
        BackHandler.exitApp();
    });
})();
