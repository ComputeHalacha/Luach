import PushNotification from 'react-native-push-notification';
import DeviceInfo from 'react-native-device-info';
import Utils from './JCal/Utils';
import { GLOBALS, log, range } from './GeneralUtils';

const NotificationEventType = Object.freeze({
    Hefsek: 101,
    MorningBedika: 102,
    AfternoonBedika: 103,
    Mikvah: 104,
    FlaggedDayOnah: 105,
    FlaggedNightOnah: 106,
});

export function configureNotifier(onRegister, onNotification) {
    log('PushNotification.configure is being called.');

    PushNotification.configure({
        // (optional) Called when Token is generated (iOS and Android)
        onRegister: function(token) {
            log('PushNotification.onRegister called: TOKEN: ', token);
            if (onRegister) {
                onRegister(token);
            }
        },

        // (required) Called when a remote or local notification is opened or received
        onNotification: async function(notification) {
            log(
                'PushNotification.OnNotification being called: NOTIFICATION: ' +
                    JSON.stringify(notification)
            );
            if (onNotification) {
                onNotification(notification);
            }
            if (GLOBALS.IS_IOS) {
                notification.finish(PushNotification.FetchResult.NoData);
            }
        },
        permissions: {
            alert: true,
            badge: true,
            sound: true,
        },
        popInitialNotification: true,
        requestPermissions: true,
    });
}

/**
 * Adds a system local scheduled notification
 * @param {Number} id
 * @param {String} title
 * @param {String} message
 * @param {Date} date
 */
function addNotification(id, title, message, date) {
    if (date.getTime() < new Date().getTime()) {
        log(
            'PushNotification.localNotificationSchedule  - notification date is after the current date. No notification will be scheduled.' +
                JSON.stringify({ id, title, message, date })
        );
    } else {
        PushNotification.localNotificationSchedule({
            date,
            message,
            id: id.toString(), // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
            userInfo: { id: id.toString() },
            ticker: 'Luach Alarm',
            autoCancel: true,
            largeIcon: 'ic_launcher', // (optional) default: "ic_launcher"
            smallIcon: 'ic_notification', // (optional) default: "ic_notification" with fallback for "ic_launcher"
            bigText: message,
            subText: title,
            //color: '@android:color/scroll', // (optional) default: system default
            vibrate: true,
            vibration: 1000,
            tag: title, // (optional) add tag to message
            group: 'Luach Reminders', // (optional) add group to message
            ongoing: false,
            priority: 'high',
            visibility: 'private',
            importance: 'high',
            alertAction: 'view', // (optional) default: view
            category: null, // (optional) default: null
            title: title,
            playSound: true,
            soundName: 'default',
            number: '10',
            //repeatType: 'day', // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
            actions: '[]',
        });
        log(
            'PushNotification.localNotificationSchedule ' +
                JSON.stringify({ id, title, message, date })
        );
    }
}

/**
 *
 * @param {id:number} id
 */
export function cancelAlarm(id) {
    PushNotification.cancelLocalNotifications({
        id: id.toString(),
    });
}

/**
 *
 */
export function cancelAllAlarms() {
    PushNotification.cancelAllLocalNotifications();
}

/**
 *
 * @param {taharaEventId:number} id
 */
export function cancelAllMorningBedikaAlarms(taharaEventId) {
    for (let i of range(7)) {
        try {
            cancelAlarm(
                `${NotificationEventType.MorningBedika}${taharaEventId}${i}`
            );
        } catch (e) {
            /*Nu, nu*/
        }
    }
}

/**
 *
 * @param {taharaEventId:number} id
 */
export function cancelAllAfternoonBedikaAlarms(taharaEventId) {
    for (let i of range(7)) {
        try {
            cancelAlarm(
                `${NotificationEventType.AfternoonBedika}${taharaEventId}${i}`
            );
        } catch (e) {
            /*Nu, nu*/
        }
    }
}

/**
 *
 * @param {taharaEventId:number} id
 */
export function cancelAllBedikaAlarms(taharaEventId) {
    cancelAllMorningBedikaAlarms(taharaEventId);
    cancelAllAfternoonBedikaAlarms(taharaEventId);
}

/**
 *
 */
export function cancelMikvaAlarm() {
    try {
        cancelAlarm(NotificationEventType.Mikvah);
    } catch (e) {
        /*Nu, nu*/
    }
}

/**
 * Cancels the "Do a Hefsek" reminder (if available)
 */
export function cancelHefsekTaharaAlarm() {
    try {
        cancelAlarm(NotificationEventType.Hefsek);
    } catch (e) {
        /*Nu, nu*/
    }
}

/**
 * Creates a system reminder to do a hefsek tahara on the given date and time.
 * @param {JDate} jdate
 * @param {{hour:Number, minute:Number}} time
 * @param {{hour:Number, minute:Number}} sunset
 * @param  {discreet:Boolean} discreet
 */
export function addHefsekTaharaAlarm(jdate, time, sunset, discreet) {
    const hefsekText = discreet ? 'H.T.' : 'Hefsek Tahara',
        sdate = jdate.getDate();
    sdate.setHours(time.hour, time.minute, 0);
    addNotification(
        NotificationEventType.Hefsek,
        `Luach - ${hefsekText} Reminder`,
        `A  ${hefsekText} may be possible today before shkiah.\nSunset today is at ${Utils.getTimeString(
            sunset,
            DeviceInfo.is24Hour
        )}.`,
        sdate
    );
}

/**
 *
 * @param {hefsekJdate} hefsekJdate
 * @param {Number} dayNumber
 * @param {string} description
 * @param {{hour:Number, minute:Number}} time
 * @param {Number} taharaEventId
 * @param  {Boolean} discreet
 */
export function addMorningBedikaAlarms(
    hefsekJdate,
    taharaEventId,
    time,
    discreet
) {
    const bedikaText = discreet ? 'B.' : 'Bedikah',
        //Secular Date of hefsek
        sdate = hefsekJdate.getDate();
    //Set the correct reminder time
    sdate.setHours(time.hour, time.minute, 0);
    for (let i of range(7)) {
        //Next day...
        sdate.setDate(sdate.getDate() + 1);
        addNotification(
            `${NotificationEventType.MorningBedika}${taharaEventId}${i}`,
            `Luach - ${bedikaText} Reminder`,
            `Today is the ${Utils.toSuffixed(i)} day of the ${
                this.discreet ? '7' : 'Shiva Neki\'im'
            }.\nThis is a reminder to do the morning ${bedikaText}`,
            sdate
        );
    }
}
/**
 *
 * @param {hefsekJdate} hefsekJdate
 * @param {Number} dayNumber
 * @param {string} description
 * @param {Number} hoursBeforeSunset
 * @param {Location} location
 * @param {Number} taharaEventId
 * @param {Boolean} discreet
 */
export function addAfternoonBedikaAlarms(
    hefsekJdate,
    taharaEventId,
    hoursBeforeSunset,
    location,
    discreet
) {
    const bedikaText = discreet ? 'B.' : 'Bedikah',
        //Secular Date of hefsek
        sdate = hefsekJdate.getDate();

    for (let i of range(7)) {
        const jdate = hefsekJdate.addDays(i),
            { sunset } = jdate.getSunTimes(location);

        //Next secular day...
        sdate.setDate(sdate.getDate() + 1);
        //Set the correct reminder time
        sdate.setHours(sunset.hour + hoursBeforeSunset, sunset.minute, 0);

        addNotification(
            `${NotificationEventType.AfternoonBedika}${taharaEventId}${i}`,
            `Luach - ${bedikaText} Reminder`,
            `Today is the ${Utils.toSuffixed(i)} day of the ${
                this.discreet ? '7' : 'Shiva Neki\'im'
            }.\nThis is a reminder to do the afternoon ${bedikaText}.\nSunset is at ${Utils.getTimeString(
                sunset,
                DeviceInfo.is24Hour
            )}`,
            sdate
        );
    }
}
/**
 *
 * @param {JDate} jdate
 * @param {{hour:Number, minute:Number}} time
 * @param {{hour:Number, minute:Number}} sunset
 * @param  {discreet:Boolean} discreet
 */
export function addMikvaAlarm(jdate, time, sunset, discreet) {
    const txt = discreet ? 'M.' : 'Mikvah',
        sdate = jdate.getDate();
    sdate.setHours(time.hour, time.minute, 0);
    addNotification(
        NotificationEventType.Mikvah,
        `Luach - ${txt} Reminder`,
        `This is a reminder ${
            discreet ? 'about' : 'to go to'
        } the ${txt} tonight.\nSunset is at ${Utils.getTimeString(
            sunset,
            DeviceInfo.is24Hour
        )}.`,
        sdate
    );
}
/**
 *
 * @param {[ProblemOnah]} problemOnahs
 * @param {Number} remindDayOnahHour
 * @param {Location} location
 * @param {Boolean} discreet
 */
export function resetDayOnahReminders(
    problemOnahs,
    remindDayOnahHour,
    location,
    discreet
) {
    removeAllDayOnahReminders();
    let counter = 1;
    for (let po of problemOnahs) {
        if (counter >= 25) {
            break;
        }
        const { jdate } = po,
            { sunrise } = jdate.getSunriseSunset(location),
            sunriseString = Utils.getTimeString(sunrise, DeviceInfo.is24Hour),
            sdate = jdate.getDate();
        sdate.setHours(sunrise.hour + remindDayOnahHour, sunrise.minute, 0);
        addNotification(
            `${NotificationEventType.FlaggedDayOnah}${counter}`,
            'Luach - Daytime flagged date notification',
            (discreet
                ? `The daytime of ${jdate.toString()} needs to be observed.`
                : po.toString()) + `\nSunrise is at ${sunriseString}`,
            sdate
        );
        counter++;
    }
}
/**
 *
 * @param {[ProblemOnah]} problemOnahs
 * @param {Number} remindNightOnahHour
 * @param {Location} location
 * @param {Boolean} discreet
 */
export function resetNightOnahReminders(
    problemOnahs,
    remindNightOnahHour,
    location,
    discreet
) {
    removeAllNightOnahReminders();
    let counter = 1;
    for (let po of problemOnahs) {
        if (counter >= 25) {
            break;
        }
        const { jdate } = po,
            { sunset } = jdate.getSunriseSunset(location),
            sunsetString = Utils.getTimeString(sunset, DeviceInfo.is24Hour),
            sdate = jdate.getDate();
        sdate.setHours(sunset.hour + remindNightOnahHour, sunset.minute, 0);
        addNotification(
            `${NotificationEventType.FlaggedNightOnah}${counter}`,
            'Luach - Nighttime flagged date notification',
            (discreet
                ? `The nighttime of ${jdate.toString()} needs to be observed.`
                : po.toString()) + `\nSunset is at ${sunsetString}`,
            sdate
        );
        counter++;
    }
}
export function removeAllDayOnahReminders() {
    for (let i of range(25)) {
        try {
            cancelAlarm(`${NotificationEventType.FlaggedDayOnah}${i}`);
        } catch (e) {
            /*Nu, nu*/
        }
    }
}
export function removeAllNightOnahReminders() {
    for (let i of range(25)) {
        try {
            cancelAlarm(`${NotificationEventType.FlaggedNightOnah}${i}`);
        } catch (e) {
            /*Nu, nu*/
        }
    }
}
